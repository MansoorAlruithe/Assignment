White-Box and BlackBox
=======================

Comparison between White-box and Black-box Test
=======================
Introduction
=======================
Software testing is aimed at assessing the differences that may exist between required conditions and existing conditions (Myers et al. 2011).
The information gained from the assessment can be used to gauge the quality of the software under test. The assessment can also
provide an overview of the risks of implementing the software. To achieve the testing objectives,
both black-box testing and white-box testing can be used. This paper contains a deep comparison between black box and white box testing;
it explains the use and meaning of each type of testing, lists the advantages and disadvantages of each type,
and also provides some examples for each type of testing to highlight the differences between the two types of testing. 



1.1 Black box testing
=======================
1.1.1 Overview
=======================
Black-box testing is a functional and behavioral testing technique which is used in determination of whether or not a program performs 
what it is supposed to, functionally(Beizer 1995). Black-box testing concentrates on the results of the software by providing input and 
examining the output without knowing how this software has been implemented (Stepp, nd). The idea of the software product being 
tested without the knowledge of implementation – black-box – gives it the name black-box testing(Beizer 1995).
Although the tester might have had a look at the code before testing, he/she has no access to the source code while executing the black-box test; 
tester only deals with the application user interface and executes a pre-designed test cases(Beizer 1995). Black-box testing ensures that 
application functionality is working as expected, it is also known as functional testing or data driven testing. The three major approaches in black-box testing include the analysis of input and output to a software application domain of the program; the analysis of observable black-box behavior; and heuristics analysis(Beizer 1995). 


1.1.2 Advantages of black box testing
===============================
To start with, testing a huge software application with enormous amount of code can be tedious and time consuming. 
Although it is important, the efficiency with which black-box testing bring to the tester allows him or her to identify efficiently the main areas where debugging is required. In addition, this can be done is a very short time(Schroeder and Korel 2000). Further, the tester does not require the help of code to do the tests. However, the tester must access a functional user interface of the software application on which the test has to be done(Schroeder & Korel 2000). Although the tester might be a developer, he/she must behave like a user – for this reason, black-box testing separates the developers’ perspective from the user’s perspective(Schroeder & Korel 2000). In addition, non-technical testers can be used in testing as long as they are given an outline on how the software application is supposed to function(Schroeder & Korel 2000). Despite this, the tester is not required to have a full functional knowledge of the software application. It is imperative to note that black-box testing helps the developers to identify vagueness and contradictions in functional specifications of software applications(Schroeder & Korel 2000). Test cases can be designed as soon as the functional implementation of the software system has been completed.

These advantages are summarized below:
	- It is efficient for large code.

	- It is consumes less time and effort comparing to white box testing.

	- It doesn’t require code access.

	- It clearly separates developer perspective from the user perspective.

	- Low skilled testers can test the system without being aware of how it is implemented.

	- The testers do not require to have a full functional knowledge of the system.

	- Black-box testing helps the developers identify contradictions in functional specifications.



1.1.3 Disadvantages of black box testing
========================================
Beside the advantages that black-box testing brings to software testing, it is inevitable for the testing method to have its flows. First, “tester is not required to have a full functional requirement” brings a challenge to designing test cases(Schroeder & Korel 2000). This is because the user might test some functions and leave out other functions. It is also possible that the user cannot identify all the requirements(Schroeder & Korel 2000). Software specifications are important in building any test cases. This type of testing does not guarantee the knowledge of specifications which offers a big challenge and can lead to building vague test cases(Schroeder & Korel 2000). This is complimented by the difficulty to point out all inputs and their required outputs; pointing out these important parameters can make the process slow and difficult especially for a non-technical user(Beizer 1995;Schroeder & Korel 2000). Consequently, there is high probability of leaving out testing paths in the process. It is important to point out that this testing method is not suitable in some cases – for instance, testing of algorithms(Beizer 1995;Schroeder & Korel 2000).

	- It has a limited coverage, as it only execute a selected number of test cases.

	- Testers have limited knowledge about the system being under test.

	- It blindly covers the system features, since the tester has no access to source code.

	- Test cases are difficult to be designed.

	- It is not suitable in some cases like testing algorithms.

	- The tester might repeat tests done by the developer.

	- Some test paths might be skipped during the process.


Examples of black box testing for my version of Game 2048
==========================================================
 
Unit Test 1 – Application randomly populates tow tiles at game start
====================================================================

Prerequisites and conditions:
-----------------------------
1-	Game is started.

Scenario:
---------
1-	User starts the game.

2-	Board is displayed to user.

Scope of execution:
-------------------
This test case insures that application randomly populates tow tiles at game start.

Expected result:
----------------
Tow tiles to be randomly populated by 2 or 4 values “randomly”.

Success criteria:
-----------------
Game board should be displayed showing tow random tiles have random values 2 or 4.

Actual result:
--------------
Game board is displayed showing tow random tiles with random values 2 or 4.

Status:
-------
Passed


Unit test 2 – Application randomly populates one tile after each user move

Prerequisites and conditions:
-----------------------------
1-	Game is started.

Scenario:
---------
1-	User starts the game.

2-	Board is displayed to user.

3-	User makes move to left, right, top, or down.

Scope of execution:
-------------------
This test case insures that application randomly populates one tile after user moves.

Expected result:
----------------
One free tile to be randomly populated by 2 or 4 values “randomly”.

Success criteria:
-----------------
Game board should be displayed showing new random tile with random value 2 or 4.

Actual result:
--------------
Game board is displayed showing new random tile with random value 2 or 4.

Status:
-------
Passed


Unit test 3 – Application exits when board is full
Prerequisites and conditions:
-----------------------------
1-	Game is started.

Scenario:
---------
1-	User starts the game.

2-	Board is displayed to user.

3-	User makes move to left, right, top, or down.

4-	New tile is populated with random value 2 or 4.

5-	Repeat steps from 2 to 4 until all tiles are populated, and board is full.

Scope of execution:
-------------------
This test case insures that application exits when board is full.

Expected result:
----------------
Application should exit and display “Game over” message to user.

Success criteria:
-----------------
Application exits and displays “Game over” message to user.

Actual result:
--------------
Application exited and displayed “Game over” message to user.

Status:
-------
Passed

